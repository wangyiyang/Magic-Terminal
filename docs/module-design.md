# Magic Terminal æ¨¡å—è®¾è®¡æ–‡æ¡£

## ğŸ—ï¸ æ¨¡å—æ¶æ„æ¦‚è§ˆ

Magic Terminal é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œå°†å¤æ‚çš„ç»ˆç«¯æ¨¡æ‹Ÿå™¨åŠŸèƒ½åˆ†è§£ä¸ºç‹¬ç«‹ã€å¯ç»´æŠ¤çš„æ¨¡å—ã€‚æ¯ä¸ªæ¨¡å—éƒ½æœ‰æ˜ç¡®çš„èŒè´£å’Œæ¸…æ™°çš„æ¥å£ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      åº”ç”¨å±‚ (Application Layer)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      æ ¸å¿ƒå±‚ (Core Layer)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Terminal  â”‚ â”‚   Config    â”‚ â”‚   State     â”‚ â”‚ Events   â”‚ â”‚
â”‚  â”‚   Manager   â”‚ â”‚   Manager   â”‚ â”‚   Manager   â”‚ â”‚ System   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    åè®®å±‚ (Protocol Layer)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚    ANSI     â”‚ â”‚     OSC     â”‚ â”‚     APC     â”‚ â”‚  Color   â”‚ â”‚
â”‚  â”‚   Handler   â”‚ â”‚   Handler   â”‚ â”‚   Handler   â”‚ â”‚ Handler  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   è¾“å…¥è¾“å‡ºå±‚ (I/O Layer)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Input     â”‚ â”‚   Output    â”‚ â”‚   Mouse     â”‚ â”‚ Selectionâ”‚ â”‚
â”‚  â”‚  Handler    â”‚ â”‚  Processor  â”‚ â”‚  Handler    â”‚ â”‚ Manager  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ¸²æŸ“å±‚ (Rendering Layer)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Render    â”‚ â”‚   TermGrid  â”‚ â”‚    Font     â”‚ â”‚  Theme   â”‚ â”‚
â”‚  â”‚   Engine    â”‚ â”‚   Widget    â”‚ â”‚   Manager   â”‚ â”‚ Manager  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   å¹³å°å±‚ (Platform Layer)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚    Unix     â”‚ â”‚   Windows   â”‚ â”‚     BSD     â”‚            â”‚
â”‚  â”‚    PTY      â”‚ â”‚   ConPTY    â”‚ â”‚    PTY      â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“¦ æ ¸å¿ƒæ¨¡å—è¯¦ç»†è®¾è®¡

### 1. Terminal Core Module (term.go)

#### èŒè´£
- ç»ˆç«¯ç”Ÿå‘½å‘¨æœŸç®¡ç†
- æ ¸å¿ƒçŠ¶æ€ç»´æŠ¤
- æ¨¡å—åè°ƒå’Œé€šä¿¡
- å…¬å…± API æä¾›

#### å…³é”®ç»„ä»¶

```go
// Terminal æ ¸å¿ƒç»“æ„
type Terminal struct {
    widget.BaseWidget
    fyne.ShortcutHandler
    
    // æ ¸å¿ƒç»„ä»¶
    content      *widget2.TermGrid    // æ˜¾ç¤ºç»„ä»¶
    config       Config               // é…ç½®ç®¡ç†
    state        State                // çŠ¶æ€ç®¡ç†
    
    // I/O ç»„ä»¶
    pty          PTYInterface         // å¹³å°æŠ½è±¡ PTY
    inputHandler *InputHandler        // è¾“å…¥å¤„ç†å™¨
    outputProc   *OutputProcessor     // è¾“å‡ºå¤„ç†å™¨
    
    // åè®®å¤„ç†å™¨
    escapeHandler *EscapeHandler      // ANSI è½¬ä¹‰åºåˆ—
    oscHandler    *OSCHandler         // OSC å‘½ä»¤
    apcHandler    *APCHandler         // APC å‘½ä»¤
    colorHandler  *ColorHandler       // é¢œè‰²å¤„ç†
    
    // æ¸²æŸ“ç»„ä»¶
    renderer     *RenderEngine       // æ¸²æŸ“å¼•æ“
    fontManager  *FontManager        // å­—ä½“ç®¡ç†
    themeManager *ThemeManager       // ä¸»é¢˜ç®¡ç†
    
    // äº‹ä»¶ç³»ç»Ÿ
    eventBus     *EventBus           // äº‹ä»¶æ€»çº¿
    listeners    []ConfigListener    // é…ç½®ç›‘å¬å™¨
    
    // åŒæ­¥æ§åˆ¶
    mu           sync.RWMutex        // è¯»å†™é”
    cancelFunc   context.CancelFunc  // å–æ¶ˆå‡½æ•°
}
```

#### æ ¸å¿ƒæ–¹æ³•

```go
// ç”Ÿå‘½å‘¨æœŸç®¡ç†
func (t *Terminal) Start() error
func (t *Terminal) Stop() error  
func (t *Terminal) Restart() error

// é…ç½®ç®¡ç†
func (t *Terminal) SetConfig(config Config) error
func (t *Terminal) GetConfig() Config
func (t *Terminal) UpdateConfig(updates ConfigUpdate) error

// çŠ¶æ€ç®¡ç†
func (t *Terminal) GetState() State
func (t *Terminal) SetState(state State)

// I/O æ“ä½œ
func (t *Terminal) Write(data []byte) (int, error)
func (t *Terminal) Read(data []byte) (int, error)

// äº‹ä»¶ç®¡ç†
func (t *Terminal) AddListener(listener ConfigListener)
func (t *Terminal) EmitEvent(event Event)
```

### 2. Configuration Module (config.go)

#### èŒè´£
- é…ç½®æ•°æ®ç»“æ„å®šä¹‰
- é…ç½®éªŒè¯å’Œé»˜è®¤å€¼
- é…ç½®æŒä¹…åŒ–
- é…ç½®å˜æ›´é€šçŸ¥

#### é…ç½®ç»“æ„

```go
type Config struct {
    // åŸºæœ¬è®¾ç½®
    Title         string        `json:"title"`
    Rows          uint          `json:"rows"`
    Columns       uint          `json:"columns"`
    
    // Shell è®¾ç½®
    Shell         string        `json:"shell"`
    ShellArgs     []string      `json:"shell_args"`
    WorkingDir    string        `json:"working_dir"`
    Environment   []string      `json:"environment"`
    
    // æ˜¾ç¤ºè®¾ç½®
    Colors        ColorScheme   `json:"colors"`
    Font          FontConfig    `json:"font"`
    Theme         string        `json:"theme"`
    
    // è¡Œä¸ºè®¾ç½®
    ScrollBack    uint          `json:"scroll_back"`
    CursorBlink   bool          `json:"cursor_blink"`
    MouseSupport  bool          `json:"mouse_support"`
    
    // é«˜çº§è®¾ç½®
    BufferSize    uint          `json:"buffer_size"`
    FlowControl   bool          `json:"flow_control"`
    LocalEcho     bool          `json:"local_echo"`
}

// é…ç½®ç®¡ç†å™¨
type ConfigManager struct {
    config       Config
    defaults     Config
    validators   []ConfigValidator
    listeners    []ConfigChangeListener
    mu           sync.RWMutex
}
```

#### é…ç½®éªŒè¯

```go
type ConfigValidator func(Config) error

// å†…ç½®éªŒè¯å™¨
func ValidateBasicConfig(config Config) error {
    if config.Rows == 0 || config.Rows > MaxRows {
        return fmt.Errorf("invalid rows: %d", config.Rows)
    }
    if config.Columns == 0 || config.Columns > MaxColumns {
        return fmt.Errorf("invalid columns: %d", config.Columns)
    }
    return nil
}

func ValidateShellConfig(config Config) error {
    if config.Shell == "" {
        return fmt.Errorf("shell cannot be empty")
    }
    if _, err := os.Stat(config.Shell); os.IsNotExist(err) {
        return fmt.Errorf("shell not found: %s", config.Shell)
    }
    return nil
}
```

### 3. Input Processing Module (input.go)

#### èŒè´£
- é”®ç›˜è¾“å…¥å¤„ç†
- è¾“å…¥äº‹ä»¶è½¬æ¢
- å¿«æ·é”®ç®¡ç†
- è¾“å…¥ç¼“å†²ç®¡ç†

#### è¾“å…¥å¤„ç†å™¨

```go
type InputHandler struct {
    terminal     *Terminal
    buffer       *InputBuffer
    keyMap       *KeyMap
    shortcuts    map[fyne.KeyName]ShortcutHandler
    inputMode    InputMode
    mu           sync.Mutex
}

type InputBuffer struct {
    data         []byte
    position     int
    capacity     int
    mu           sync.Mutex
}

type KeyMap struct {
    mappings     map[fyne.KeyName][]byte
    modifiers    map[fyne.KeyModifier]string
}
```

#### è¾“å…¥å¤„ç†æµç¨‹

```go
// é”®ç›˜äº‹ä»¶å¤„ç†
func (h *InputHandler) HandleKeyEvent(event *fyne.KeyEvent) bool {
    // 1. æ£€æŸ¥å¿«æ·é”®
    if h.handleShortcut(event) {
        return true
    }
    
    // 2. æ¨¡å¼ç‰¹å®šå¤„ç†
    switch h.inputMode {
    case ModeNormal:
        return h.handleNormalMode(event)
    case ModeApplication:
        return h.handleApplicationMode(event)
    case ModeInsert:
        return h.handleInsertMode(event)
    }
    
    return false
}

// è¾“å…¥è½¬æ¢
func (h *InputHandler) ConvertToBytes(event *fyne.KeyEvent) []byte {
    // ç‰¹æ®Šé”®å¤„ç†
    if sequence, exists := h.keyMap.mappings[event.Name]; exists {
        return h.applyModifiers(sequence, event.Modifier)
    }
    
    // æ™®é€šå­—ç¬¦
    if event.Text != "" {
        return []byte(event.Text)
    }
    
    return nil
}
```

### 4. Output Processing Module (output.go)

#### èŒè´£
- è¾“å‡ºæ•°æ®å¤„ç†
- è½¬ä¹‰åºåˆ—è§£æ
- æ˜¾ç¤ºçŠ¶æ€æ›´æ–°
- è¾“å‡ºç¼“å†²ç®¡ç†

#### è¾“å‡ºå¤„ç†å™¨

```go
type OutputProcessor struct {
    terminal     *Terminal
    parser       *ANSIParser
    buffer       *OutputBuffer
    charset      CharSet
    state        ProcessorState
    mu           sync.Mutex
}

type OutputBuffer struct {
    data         []byte
    readPos      int
    writePos     int
    size         int
    overflow     bool
    mu           sync.RWMutex
}

type ANSIParser struct {
    state        ParserState
    sequence     []byte
    parameters   []int
    intermediate []byte
}
```

#### è¾“å‡ºå¤„ç†æµç¨‹

```go
func (p *OutputProcessor) ProcessOutput(data []byte) error {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    for _, b := range data {
        switch p.parser.state {
        case StateNormal:
            p.processNormalChar(b)
        case StateEscape:
            p.processEscapeChar(b)
        case StateCSI:
            p.processCSIChar(b)
        case StateOSC:
            p.processOSCChar(b)
        }
    }
    
    return p.flushUpdates()
}

func (p *OutputProcessor) processNormalChar(b byte) {
    // å¤„ç†æ™®é€šå­—ç¬¦
    if unicode.IsPrint(rune(b)) {
        p.addCharacter(b)
    } else {
        p.processControlChar(b)
    }
}
```

### 5. Color Management Module (color.go)

#### èŒè´£
- é¢œè‰²è§£æå’Œè½¬æ¢
- é¢œè‰²æ–¹æ¡ˆç®¡ç†
- ANSI é¢œè‰²æ”¯æŒ
- çœŸå½©è‰²æ”¯æŒ

#### é¢œè‰²ç®¡ç†å™¨

```go
type ColorHandler struct {
    scheme       ColorScheme
    palette      [256]color.Color  // 256è‰²è°ƒè‰²æ¿
    trueColor    bool              // çœŸå½©è‰²æ”¯æŒ
    cache        map[string]color.Color
    mu           sync.RWMutex
}

type ColorScheme struct {
    // åŸºæœ¬é¢œè‰²
    Foreground    color.Color
    Background    color.Color
    
    // æ ‡å‡† 16 è‰²
    Black         color.Color
    Red           color.Color
    Green         color.Color
    Yellow        color.Color
    Blue          color.Color
    Magenta       color.Color
    Cyan          color.Color
    White         color.Color
    
    // äº®è‰²ç‰ˆæœ¬
    BrightBlack   color.Color
    BrightRed     color.Color
    BrightGreen   color.Color
    BrightYellow  color.Color
    BrightBlue    color.Color
    BrightMagenta color.Color
    BrightCyan    color.Color
    BrightWhite   color.Color
}
```

#### é¢œè‰²å¤„ç†æ–¹æ³•

```go
// ANSI é¢œè‰²è§£æ
func (c *ColorHandler) ParseANSIColor(code int) color.Color {
    switch {
    case code >= 0 && code <= 7:
        return c.scheme.getStandardColor(code)
    case code >= 8 && code <= 15:
        return c.scheme.getBrightColor(code - 8)
    case code >= 16 && code <= 231:
        return c.palette[code]
    case code >= 232 && code <= 255:
        return c.getGrayscaleColor(code - 232)
    default:
        return c.scheme.Foreground
    }
}

// RGB é¢œè‰²è§£æ
func (c *ColorHandler) ParseRGBColor(r, g, b uint8) color.Color {
    if !c.trueColor {
        return c.findNearestPaletteColor(r, g, b)
    }
    return color.RGBA{R: r, G: g, B: b, A: 255}
}
```

### 6. Rendering Module (render.go)

#### èŒè´£
- å­—ç¬¦ç½‘æ ¼æ¸²æŸ“
- æ€§èƒ½ä¼˜åŒ–
- è„åŒºåŸŸç®¡ç†
- åŒç¼“å†²å®ç°

#### æ¸²æŸ“å¼•æ“

```go
type RenderEngine struct {
    terminal     *Terminal
    canvas       fyne.Canvas
    grid         *TermGrid
    fontManager  *FontManager
    
    // ç¼“å†²åŒº
    frontBuffer  [][]Cell
    backBuffer   [][]Cell
    dirtyRegions []Region
    
    // æ¸²æŸ“çŠ¶æ€
    lastRender   time.Time
    frameCount   int64
    renderStats  RenderStats
    
    mu           sync.Mutex
}

type Cell struct {
    Char         rune
    Foreground   color.Color
    Background   color.Color
    Attributes   CellAttributes
    Width        int  // å­—ç¬¦å®½åº¦ï¼ˆUnicode å®½å­—ç¬¦æ”¯æŒï¼‰
}

type CellAttributes struct {
    Bold         bool
    Italic       bool
    Underline    bool
    Strikethrough bool
    Blink        bool
    Reverse      bool
    Dim          bool
}
```

#### æ¸²æŸ“ä¼˜åŒ–

```go
// è„åŒºåŸŸæ¸²æŸ“
func (r *RenderEngine) Render() error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if len(r.dirtyRegions) == 0 {
        return nil // æ— éœ€æ¸²æŸ“
    }
    
    // åˆå¹¶é‡å åŒºåŸŸ
    regions := r.mergeDirtyRegions()
    
    // æ¸²æŸ“æ¯ä¸ªåŒºåŸŸ
    for _, region := range regions {
        r.renderRegion(region)
    }
    
    // äº¤æ¢ç¼“å†²åŒº
    r.swapBuffers()
    
    // æ¸…ç†è„åŒºåŸŸ
    r.dirtyRegions = r.dirtyRegions[:0]
    
    return nil
}

// å¢é‡æ¸²æŸ“
func (r *RenderEngine) markDirty(row, col, width, height int) {
    region := Region{
        X: col, Y: row,
        Width: width, Height: height,
    }
    r.dirtyRegions = append(r.dirtyRegions, region)
}
```

### 7. Platform Abstraction Module

#### èŒè´£
- å¹³å°å·®å¼‚æŠ½è±¡
- PTY æ¥å£ç»Ÿä¸€
- å¹³å°ç‰¹å®šä¼˜åŒ–

#### PTY æ¥å£

```go
type PTYInterface interface {
    Start(shell string, args []string) error
    Stop() error
    Read([]byte) (int, error)
    Write([]byte) (int, error)
    Resize(rows, cols int) error
    GetSize() (rows, cols int, err error)
    SetRaw() error
    Restore() error
}

// Unix å®ç°
type UnixPTY struct {
    pty    *os.File
    tty    *os.File
    cmd    *exec.Cmd
    size   Size
    mu     sync.Mutex
}

// Windows å®ç°  
type WindowsPTY struct {
    conpty HPCON
    input  *os.File
    output *os.File
    cmd    *exec.Cmd
    size   Size
    mu     sync.Mutex
}
```

## ğŸ”„ æ¨¡å—é—´é€šä¿¡

### 1. äº‹ä»¶æ€»çº¿ç³»ç»Ÿ

```go
type EventBus struct {
    subscribers map[EventType][]EventHandler
    mu          sync.RWMutex
}

type Event struct {
    Type      EventType
    Source    string
    Data      interface{}
    Timestamp time.Time
}

type EventHandler func(Event) error

// äº‹ä»¶ç±»å‹
const (
    EventConfigChanged EventType = iota
    EventStateChanged
    EventOutputReceived
    EventInputReceived
    EventSizeChanged
    EventColorSchemeChanged
)
```

### 2. æ¨¡å—åˆå§‹åŒ–å’Œä¾èµ–æ³¨å…¥

```go
type ModuleManager struct {
    modules     map[string]Module
    dependencies map[string][]string
    initialized  map[string]bool
    mu          sync.Mutex
}

type Module interface {
    Name() string
    Dependencies() []string
    Initialize(deps ModuleDependencies) error
    Start() error
    Stop() error
}

// æ¨¡å—æ³¨å†Œå’Œå¯åŠ¨
func (m *ModuleManager) RegisterModule(module Module) {
    m.modules[module.Name()] = module
    m.dependencies[module.Name()] = module.Dependencies()
}

func (m *ModuleManager) StartAll() error {
    // æ‹“æ‰‘æ’åºä¾èµ–
    order, err := m.resolveDependencies()
    if err != nil {
        return err
    }
    
    // æŒ‰é¡ºåºåˆå§‹åŒ–æ¨¡å—
    for _, name := range order {
        if err := m.startModule(name); err != nil {
            return fmt.Errorf("failed to start module %s: %w", name, err)
        }
    }
    
    return nil
}
```

### 3. é…ç½®åŒæ­¥æœºåˆ¶

```go
// é…ç½®å˜æ›´å¹¿æ’­
func (t *Terminal) broadcastConfigChange(config Config) {
    event := Event{
        Type:   EventConfigChanged,
        Source: "terminal",
        Data:   config,
    }
    
    t.eventBus.Emit(event)
    
    // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
    for _, listener := range t.listeners {
        select {
        case listener <- config:
        default:
            // éé˜»å¡å‘é€
        }
    }
}
```

## ğŸ“Š æ€§èƒ½è€ƒè™‘

### 1. å†…å­˜ç®¡ç†

```go
// å¯¹è±¡æ± æ¨¡å¼
type CellPool struct {
    pool sync.Pool
}

func (p *CellPool) Get() *Cell {
    cell := p.pool.Get().(*Cell)
    // é‡ç½® cell çŠ¶æ€
    cell.Reset()
    return cell
}

func (p *CellPool) Put(cell *Cell) {
    p.pool.Put(cell)
}

// ç¼“å†²åŒºå¤ç”¨
type BufferPool struct {
    pools map[int]*sync.Pool  // æŒ‰å¤§å°åˆ†ç»„çš„ç¼“å†²æ± 
    mu    sync.RWMutex
}
```

### 2. å¹¶å‘æ§åˆ¶

```go
// è¯»å†™åˆ†ç¦»
type ConcurrentGrid struct {
    cells    [][]Cell
    readers  int32
    writing  int32
    rwMutex  sync.RWMutex
}

func (g *ConcurrentGrid) Read(row, col int) Cell {
    atomic.AddInt32(&g.readers, 1)
    defer atomic.AddInt32(&g.readers, -1)
    
    g.rwMutex.RLock()
    defer g.rwMutex.RUnlock()
    
    return g.cells[row][col]
}

func (g *ConcurrentGrid) Write(row, col int, cell Cell) {
    atomic.StoreInt32(&g.writing, 1)
    defer atomic.StoreInt32(&g.writing, 0)
    
    g.rwMutex.Lock()
    defer g.rwMutex.Unlock()
    
    g.cells[row][col] = cell
}
```

### 3. æ¸²æŸ“ä¼˜åŒ–

```go
// å¸§ç‡é™åˆ¶
type FrameRateLimiter struct {
    targetFPS    int
    lastFrame    time.Time
    frameTime    time.Duration
    dropFrame    bool
}

func (f *FrameRateLimiter) ShouldRender() bool {
    now := time.Now()
    elapsed := now.Sub(f.lastFrame)
    
    if elapsed < f.frameTime {
        f.dropFrame = true
        return false
    }
    
    f.lastFrame = now
    f.dropFrame = false
    return true
}
```

## ğŸ”§ æ‰©å±•ç‚¹å’Œæ’ä»¶æ¥å£

### 1. åè®®æ‰©å±•

```go
type ProtocolExtension interface {
    Name() string
    CanHandle(data []byte) bool
    Process(data []byte, terminal *Terminal) error
    Priority() int
}

// åè®®æ³¨å†Œå™¨
type ProtocolRegistry struct {
    extensions []ProtocolExtension
    mu         sync.RWMutex
}

func (r *ProtocolRegistry) Register(ext ProtocolExtension) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.extensions = append(r.extensions, ext)
    
    // æŒ‰ä¼˜å…ˆçº§æ’åº
    sort.Slice(r.extensions, func(i, j int) bool {
        return r.extensions[i].Priority() > r.extensions[j].Priority()
    })
}
```

### 2. ä¸»é¢˜æ‰©å±•

```go
type ThemeExtension interface {
    Name() string
    ColorScheme() ColorScheme
    FontConfig() FontConfig
    CustomProperties() map[string]interface{}
}

// ä¸»é¢˜ç®¡ç†å™¨
type ThemeManager struct {
    themes      map[string]ThemeExtension
    current     string
    customizer  ThemeCustomizer
    mu          sync.RWMutex
}
```

---

æ›´å¤šä¿¡æ¯è¯·å‚è€ƒï¼š
- [æ¶æ„è®¾è®¡](./architecture.md)
- [API æ–‡æ¡£](./api-reference.md)
- [æ€§èƒ½ä¼˜åŒ–](./performance-optimization.md)
